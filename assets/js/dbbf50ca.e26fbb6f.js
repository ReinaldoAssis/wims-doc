"use strict";(self.webpackChunkwims_docs=self.webpackChunkwims_docs||[]).push([[234],{3255:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>t,default:()=>a,frontMatter:()=>i,metadata:()=>c,toc:()=>o});var d=n(4848),r=n(8453);const i={sidebar_position:2},t="The Instruction Set",c={id:"tutorial-basics/the-instruction-set",title:"The Instruction Set",description:"Before writing any code, it's important to understand the instructions available in WIMS. The following table summarizes the instruction set:",source:"@site/docs/tutorial-basics/the-instruction-set.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/the-instruction-set",permalink:"/wims-doc/docs/tutorial-basics/the-instruction-set",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-basics/the-instruction-set.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting to Know the IDE",permalink:"/wims-doc/docs/tutorial-basics/getting-to-know-the-ide"},next:{title:"Writing Your First Program",permalink:"/wims-doc/docs/tutorial-basics/running-first-program"}},l={},o=[{value:"Explanation of Instructions",id:"explanation-of-instructions",level:3},{value:"Directives and Constants",id:"directives-and-constants",level:3},{value:"Assembler Constants",id:"assembler-constants",level:3},{value:"Examples:",id:"examples",level:4}];function h(e){const s={admonition:"admonition",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"the-instruction-set",children:"The Instruction Set"})}),"\n",(0,d.jsx)(s.p,{children:"Before writing any code, it's important to understand the instructions available in WIMS. The following table summarizes the instruction set:"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"INSTRUCTION"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"OPERATION"})}),(0,d.jsx)(s.th,{children:(0,d.jsx)(s.strong,{children:"DESCRIPTION"})})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ADD"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs + Rt"})}),(0,d.jsxs)(s.td,{children:["Adds the values in ",(0,d.jsx)(s.code,{children:"Rs"})," and ",(0,d.jsx)(s.code,{children:"Rt"}),", stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"ADDI"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs + Imm"})}),(0,d.jsxs)(s.td,{children:["Adds the immediate value ",(0,d.jsx)(s.code,{children:"Imm"})," to ",(0,d.jsx)(s.code,{children:"Rs"}),", stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"OR"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs | Rt"})}),(0,d.jsxs)(s.td,{children:["Performs a bitwise OR between ",(0,d.jsx)(s.code,{children:"Rs"})," and ",(0,d.jsx)(s.code,{children:"Rt"}),", stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"AND"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs & Rt"})}),(0,d.jsxs)(s.td,{children:["Performs a bitwise AND between ",(0,d.jsx)(s.code,{children:"Rs"})," and ",(0,d.jsx)(s.code,{children:"Rt"}),", stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SUB"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs - Rt"})}),(0,d.jsxs)(s.td,{children:["Subtracts the value in ",(0,d.jsx)(s.code,{children:"Rt"})," from ",(0,d.jsx)(s.code,{children:"Rs"}),", stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SLT"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = (Rs < Rt)"})}),(0,d.jsxs)(s.td,{children:["Sets ",(0,d.jsx)(s.code,{children:"Rd"})," to 1 if ",(0,d.jsx)(s.code,{children:"Rs"})," is less than ",(0,d.jsx)(s.code,{children:"Rt"}),", otherwise sets ",(0,d.jsx)(s.code,{children:"Rd"})," to 0."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SLTI"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = (Rs < Imm)"})}),(0,d.jsxs)(s.td,{children:["Sets ",(0,d.jsx)(s.code,{children:"Rd"})," to 1 if ",(0,d.jsx)(s.code,{children:"Rs"})," is less than the immediate value ",(0,d.jsx)(s.code,{children:"Imm"}),", otherwise sets ",(0,d.jsx)(s.code,{children:"Rd"})," to 0."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BEQ"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"if (Rs == Rt) PC = PC + Imm"})}),(0,d.jsxs)(s.td,{children:["Branches to the address ",(0,d.jsx)(s.code,{children:"PC + Imm"})," if ",(0,d.jsx)(s.code,{children:"Rs"})," is equal to ",(0,d.jsx)(s.code,{children:"Rt"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"BNE"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"if (Rs != Rt) PC = PC + Imm"})}),(0,d.jsxs)(s.td,{children:["Branches to the address ",(0,d.jsx)(s.code,{children:"PC + Imm"})," if ",(0,d.jsx)(s.code,{children:"Rs"})," is not equal to ",(0,d.jsx)(s.code,{children:"Rt"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"LW"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Memory[Rs + Imm]"})}),(0,d.jsxs)(s.td,{children:["Loads a word from memory at the address ",(0,d.jsx)(s.code,{children:"Rs + Imm"})," into ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SW"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Memory[Rs + Imm] = Rt"})}),(0,d.jsxs)(s.td,{children:["Stores the word in ",(0,d.jsx)(s.code,{children:"Rt"})," into memory at the address ",(0,d.jsx)(s.code,{children:"Rs + Imm"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"J"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"PC = Imm"})}),(0,d.jsxs)(s.td,{children:["Jumps to the address specified by ",(0,d.jsx)(s.code,{children:"Imm"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"JR"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"PC = Rs"})}),(0,d.jsxs)(s.td,{children:["Jumps to the address contained in ",(0,d.jsx)(s.code,{children:"Rs"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"JAL"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"RA = PC + 4; PC = Imm"})}),(0,d.jsxs)(s.td,{children:["Saves the return address in ",(0,d.jsx)(s.code,{children:"RA"})," and jumps to the address ",(0,d.jsx)(s.code,{children:"Imm"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 0"}),(0,d.jsx)(s.td,{children:"Halt"}),(0,d.jsx)(s.td,{children:"Stops program execution."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 1"}),(0,d.jsxs)(s.td,{children:["Print integer ",(0,d.jsx)(s.code,{children:"$v0"})]}),(0,d.jsxs)(s.td,{children:["Prints the value in ",(0,d.jsx)(s.code,{children:"$v0"})," as an integer."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 2"}),(0,d.jsxs)(s.td,{children:["Print character ",(0,d.jsx)(s.code,{children:"$v0"})]}),(0,d.jsxs)(s.td,{children:["Prints the value in ",(0,d.jsx)(s.code,{children:"$v0"})," as an ASCII character."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 3"}),(0,d.jsxs)(s.td,{children:["Print integer ",(0,d.jsx)(s.code,{children:"$v0"})," w/o newline"]}),(0,d.jsxs)(s.td,{children:["Prints the value in ",(0,d.jsx)(s.code,{children:"$v0"})," as an integer without a newline."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 42"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"$v0 = Random($a0,$a1)"})}),(0,d.jsxs)(s.td,{children:["Generates a random integer between ",(0,d.jsx)(s.code,{children:"$a0"})," and ",(0,d.jsx)(s.code,{children:"$a1"}),", stores it in ",(0,d.jsx)(s.code,{children:"$v0"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"CALL 40"}),(0,d.jsx)(s.td,{children:"Screen update"}),(0,d.jsx)(s.td,{children:"Updates the simulator's screen."})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MUL"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"LO = Rs * Rt (lower 32 bits)"})," ",(0,d.jsx)("br",{})," ",(0,d.jsx)(s.code,{children:"HI = Rs * Rt (upper 32 bits)"})]}),(0,d.jsxs)(s.td,{children:["Multiplies ",(0,d.jsx)(s.code,{children:"Rs"})," and ",(0,d.jsx)(s.code,{children:"Rt"}),", stores the lower 32 bits in ",(0,d.jsx)(s.code,{children:"LO"})," and the upper 32 bits in ",(0,d.jsx)(s.code,{children:"HI"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"DIV"}),(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"LO = Rs / Rt"})," ",(0,d.jsx)("br",{})," ",(0,d.jsx)(s.code,{children:"HI = Rs % Rt"})]}),(0,d.jsxs)(s.td,{children:["Divides ",(0,d.jsx)(s.code,{children:"Rs"})," by ",(0,d.jsx)(s.code,{children:"Rt"}),", stores the quotient in ",(0,d.jsx)(s.code,{children:"LO"})," and the remainder in ",(0,d.jsx)(s.code,{children:"HI"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MFHI"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = HI"})}),(0,d.jsxs)(s.td,{children:["Moves the value from ",(0,d.jsx)(s.code,{children:"HI"})," to ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"MFLO"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = LO"})}),(0,d.jsxs)(s.td,{children:["Moves the value from ",(0,d.jsx)(s.code,{children:"LO"})," to ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SLL"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs << Shamt"})}),(0,d.jsxs)(s.td,{children:["Shifts ",(0,d.jsx)(s.code,{children:"Rs"})," left by ",(0,d.jsx)(s.code,{children:"Shamt"})," bits, stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"SRL"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Rs >> Shamt"})}),(0,d.jsxs)(s.td,{children:["Shifts ",(0,d.jsx)(s.code,{children:"Rs"})," right by ",(0,d.jsx)(s.code,{children:"Shamt"})," bits, stores the result in ",(0,d.jsx)(s.code,{children:"Rd"}),"."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"PUSH"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Memory[SP] = Rs; SP = SP - 4"})}),(0,d.jsxs)(s.td,{children:["Pushes the value in ",(0,d.jsx)(s.code,{children:"Rs"})," onto the stack, decrements the stack pointer (",(0,d.jsx)(s.code,{children:"SP"}),")."]})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:"POP"}),(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"Rd = Memory[SP]; SP = SP + 4"})}),(0,d.jsxs)(s.td,{children:["Pops the top value from the stack into ",(0,d.jsx)(s.code,{children:"Rd"}),", increments the stack pointer (",(0,d.jsx)(s.code,{children:"SP"}),")."]})]})]})]}),"\n",(0,d.jsx)(s.h3,{id:"explanation-of-instructions",children:"Explanation of Instructions"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Arithmetic Operations:"})," Instructions like ",(0,d.jsx)(s.code,{children:"ADD"}),", ",(0,d.jsx)(s.code,{children:"SUB"}),", and ",(0,d.jsx)(s.code,{children:"MUL"})," perform basic arithmetic operations on the register contents."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Logical Operations:"})," Instructions like ",(0,d.jsx)(s.code,{children:"AND"}),", ",(0,d.jsx)(s.code,{children:"OR"}),", ",(0,d.jsx)(s.code,{children:"SLT"}),", ",(0,d.jsx)(s.code,{children:"SLTI"}),", ",(0,d.jsx)(s.code,{children:"SLL"}),", and ",(0,d.jsx)(s.code,{children:"SRL"})," handle bitwise logical operations or comparisons."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Branching and Control:"})," Instructions such as ",(0,d.jsx)(s.code,{children:"BEQ"}),", ",(0,d.jsx)(s.code,{children:"BNE"}),", ",(0,d.jsx)(s.code,{children:"J"}),", ",(0,d.jsx)(s.code,{children:"JR"}),", and ",(0,d.jsx)(s.code,{children:"JAL"})," alter the program flow based on conditions or direct jumps."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Memory Operations:"})," ",(0,d.jsx)(s.code,{children:"LW"})," and ",(0,d.jsx)(s.code,{children:"SW"})," are used to load and store data between memory and registers."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Function Calls:"})," Special ",(0,d.jsx)(s.code,{children:"CALL"})," instructions handle I/O operations like printing to the screen or generating random numbers."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Multiplication/Division:"})," The ",(0,d.jsx)(s.code,{children:"MUL"})," and ",(0,d.jsx)(s.code,{children:"DIV"})," instructions perform multiplication and division, with results stored in special registers."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:"Stack Operations:"})," The ",(0,d.jsx)(s.code,{children:"PUSH"})," and ",(0,d.jsx)(s.code,{children:"POP"})," instructions manage the stack, typically used in function calls to save and restore register values."]}),"\n"]}),"\n",(0,d.jsx)(s.h3,{id:"directives-and-constants",children:"Directives and Constants"}),"\n",(0,d.jsx)(s.p,{children:"Another important aspect of assembly programming is the use of directives. Directives give instructions to the assembler rather than the CPU. The WIMS assembler supports the following directives:"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:".org"})}),": Defines where in memory the code below it should be loaded."]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-assembly",children:".org 0x2000\n"})}),"\n",(0,d.jsx)(s.p,{children:"This sets the starting address for the code to 0x2000."}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:".dw"})}),": Defines a word in memory at the current instruction address. This can be a string (each character is stored as a word) or a number (in hexadecimal with ",(0,d.jsx)(s.code,{children:"0x"}),", binary with ",(0,d.jsx)(s.code,{children:"0b"}),", or decimal)."]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-assembly",children:'.dw "Hello"\n.dw 0x1234\n.dw 0b101010\n'})}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(s.h3,{id:"assembler-constants",children:"Assembler Constants"}),"\n",(0,d.jsx)(s.p,{children:"WIMS also includes several predefined constants:"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:"PC_START"})}),": The initial program counter address."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:"SCREEN_MEM_START"})}),": The starting address of the screen memory."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:"SCREEN_MEM_END"})}),": The ending address of the screen memory."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:"INPUT_BUFFER_ADDR"})}),": The address of the input buffer."]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.strong,{children:(0,d.jsx)(s.code,{children:"STACK_START"})}),": The starting address of the stack."]}),"\n"]}),"\n",(0,d.jsx)(s.h4,{id:"examples",children:"Examples:"}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"To start the program counter at a specific location:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-assembly",children:".org PC_START\n"})}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"To store a word at the beginning of the screen memory:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-assembly",children:".org SCREEN_MEM_START\n.dw 0xFFFF\n"})}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:"To store something at the start of the stack:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-assembly",children:".org STACK_START\n.dw 42\n"})}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(s.p,{children:"Understanding these instructions and directives will help you make the most of WIMS and write efficient, functional assembly programs."}),"\n",(0,d.jsx)(s.admonition,{title:"Pro Tip",type:"tip",children:(0,d.jsx)(s.p,{children:"Familiarize yourself with these instructions and directives to write better, more optimized assembly code."})}),"\n",(0,d.jsx)(s.admonition,{title:"Be Careful",type:"danger",children:(0,d.jsx)(s.p,{children:"Incorrect use of directives can lead to unexpected behavior in your programs. Always double-check your memory addresses and instruction order."})})]})}function a(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>c});var d=n(6540);const r={},i=d.createContext(r);function t(e){const s=d.useContext(i);return d.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),d.createElement(i.Provider,{value:s},e.children)}}}]);